#!/usr/bin/env python3
"""Git History Cleanup Tool for NetworkX MCP Server.

This script provides comprehensive git history cleanup capabilities including:
- Claude reference removal from commit messages and files
- Interactive rebase assistance
- Commit squashing recommendations
- History analysis and reporting
- Conventional commit migration
- Backup and safety mechanisms
"""

import argparse
import json
import logging
import re
import subprocess
import sys
from dataclasses import asdict, dataclass
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


# ANSI color codes
class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    PURPLE = "\033[0;35m"
    CYAN = "\033[0;36m"
    BOLD = "\033[1m"
    END = "\033[0m"


@dataclass
class CommitInfo:
    """Information about a Git commit."""

    hash: str
    short_hash: str
    author: str
    date: str
    message: str
    files_changed: list[str]
    has_claude_refs: bool = False
    needs_cleanup: bool = False
    suggested_message: str | None = None


@dataclass
class CleanupReport:
    """Report of cleanup operations."""

    total_commits: int
    commits_with_claude_refs: int
    files_with_claude_refs: int
    cleanup_operations: list[str]
    backup_created: bool
    success: bool
    error_message: str | None = None


class GitHistoryCleanup:
    """Comprehensive Git history cleanup tool."""

    def __init__(self, project_root: Path, dry_run: bool = False):
        self.project_root = project_root
        self.dry_run = dry_run
        self.commits: list[CommitInfo] = []
        self.claude_patterns = [
            r"\bclaude\b",
            r"claude[_-]?code",
            r"claude[_-]?ai",
            r"anthropic",
            r"assistant:?",
            r"claude[_-]?mcp",
            r"claude[_-]?server",
            r"@claude",
            r"by claude",
            r"from claude",
            r"claude\s+generated",
            r"claude\s+created",
            r"claude\s+wrote",
            r"claude\s+implemented",
            r"claude\s+added",
            r"claude\s+updated",
            r"claude\s+fixed",
            r"created by claude",
            r"generated by claude",
            r"claude suggestions?",
            r"claude recommendations?",
        ]
        self.cleanup_operations: list[str] = []

    def run_git_command(
        self, cmd: list[str], capture_output: bool = True
    ) -> tuple[int, str, str]:
        """Run a git command and return (returncode, stdout, stderr)."""
        try:
            logger.debug(f"Running git command: {' '.join(cmd)}")
            result = subprocess.run(
                ["git"] + cmd,
                cwd=self.project_root,
                capture_output=capture_output,
                text=True,
                timeout=300,
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            return -1, "", "Command timed out"
        except Exception as e:
            return -1, "", str(e)

    def analyze_commit_history(
        self, branch: str = "HEAD", limit: int = 100
    ) -> list[CommitInfo]:
        """Analyze commit history for Claude references."""
        logger.info(f"Analyzing commit history (last {limit} commits)...")

        # Get commit information
        returncode, stdout, stderr = self.run_git_command(
            [
                "log",
                f"--max-count={limit}",
                branch,
                "--pretty=format:%H|%h|%an|%ad|%s",
                "--date=iso",
            ]
        )

        if returncode != 0:
            logger.error(f"Failed to get commit history: {stderr}")
            return []

        commits = []
        for line in stdout.strip().split("\n"):
            if not line:
                continue

            parts = line.split("|", 4)
            if len(parts) != 5:
                continue

            hash_full, hash_short, author, date, message = parts

            # Get files changed in this commit
            returncode, files_stdout, _ = self.run_git_command(
                ["diff-tree", "--no-commit-id", "--name-only", "-r", hash_full]
            )

            files_changed = (
                files_stdout.strip().split("\n") if files_stdout.strip() else []
            )

            # Check for Claude references
            has_claude_refs = self._has_claude_references(message)

            commit = CommitInfo(
                hash=hash_full,
                short_hash=hash_short,
                author=author,
                date=date,
                message=message,
                files_changed=files_changed,
                has_claude_refs=has_claude_refs,
                needs_cleanup=has_claude_refs,
            )

            # Generate suggested clean message
            if has_claude_refs:
                commit.suggested_message = self._clean_commit_message(message)

            commits.append(commit)

        self.commits = commits
        logger.info(f"Analyzed {len(commits)} commits")

        return commits

    def _has_claude_references(self, text: str) -> bool:
        """Check if text contains Claude references."""
        text_lower = text.lower()
        for pattern in self.claude_patterns:
            if re.search(pattern, text_lower, re.IGNORECASE):
                return True
        return False

    def _clean_commit_message(self, message: str) -> str:
        """Clean Claude references from commit message."""
        cleaned = message

        # Remove common Claude phrases
        claude_phrases = [
            r"\s*\(?[Cc]laude\s+[Cc]ode\)?",
            r"\s*\(?[Bb]y\s+[Cc]laude\)?",
            r"\s*\(?[Ff]rom\s+[Cc]laude\)?",
            r"\s*\(?[Cc]laude\s+generated\)?",
            r"\s*\(?[Cc]laude\s+created\)?",
            r"\s*\(?[Cc]laude\s+implemented\)?",
            r"\s*\(?[Cc]laude\s+wrote\)?",
            r"\s*\(?[Cc]laude\s+suggestions?\)?",
            r"\s*\(?[Aa]ssistant:?\)?",
            r"\s*\([Cc]laude[^)]*\)",
            r"\s*-\s*[Cc]laude\s*$",
            r"\s*\|\s*[Cc]laude\s*$",
        ]

        for phrase in claude_phrases:
            cleaned = re.sub(phrase, "", cleaned, flags=re.IGNORECASE)

        # Clean up extra whitespace and punctuation
        cleaned = re.sub(r"\s+", " ", cleaned)
        cleaned = re.sub(r"\s*[,;]\s*$", "", cleaned)
        cleaned = cleaned.strip()

        # If message is too short after cleaning, provide a generic message
        if len(cleaned) < 10:
            if "feat" in message.lower():
                cleaned = "feat: implement new feature"
            elif "fix" in message.lower():
                cleaned = "fix: resolve issue"
            elif "doc" in message.lower():
                cleaned = "docs: update documentation"
            elif "test" in message.lower():
                cleaned = "test: add tests"
            elif "refactor" in message.lower():
                cleaned = "refactor: improve code structure"
            else:
                cleaned = "chore: update code"

        return cleaned

    def scan_files_for_claude_refs(self) -> dict[str, list[tuple[int, str]]]:
        """Scan all files for Claude references."""
        logger.info("Scanning files for Claude references...")

        files_with_refs = {}

        # Get all tracked files
        returncode, stdout, stderr = self.run_git_command(["ls-files"])
        if returncode != 0:
            logger.error(f"Failed to get file list: {stderr}")
            return {}

        files = stdout.strip().split("\n")

        for file_path in files:
            if not file_path:
                continue

            full_path = self.project_root / file_path
            if not full_path.exists() or full_path.is_dir():
                continue

            # Skip binary files
            if self._is_binary_file(full_path):
                continue

            try:
                with open(full_path, encoding="utf-8", errors="ignore") as f:
                    lines = f.readlines()

                refs_in_file = []
                for line_num, line in enumerate(lines, 1):
                    if self._has_claude_references(line):
                        refs_in_file.append((line_num, line.strip()))

                if refs_in_file:
                    files_with_refs[file_path] = refs_in_file

            except Exception as e:
                logger.warning(f"Could not scan {file_path}: {e}")

        logger.info(f"Found Claude references in {len(files_with_refs)} files")
        return files_with_refs

    def _is_binary_file(self, file_path: Path) -> bool:
        """Check if file is binary."""
        binary_extensions = {
            ".pyc",
            ".pyo",
            ".so",
            ".dylib",
            ".dll",
            ".exe",
            ".png",
            ".jpg",
            ".jpeg",
            ".gif",
            ".ico",
            ".svg",
            ".pdf",
            ".zip",
            ".tar",
            ".gz",
            ".bz2",
            ".xz",
            ".mp3",
            ".mp4",
            ".avi",
            ".mov",
            ".wav",
            ".ttf",
            ".otf",
            ".woff",
            ".woff2",
            ".db",
            ".sqlite",
            ".sqlite3",
        }

        if file_path.suffix.lower() in binary_extensions:
            return True

        # Check first few bytes for binary content
        try:
            with open(file_path, "rb") as f:
                chunk = f.read(1024)
                if b"\x00" in chunk:
                    return True
        except Exception:
            pass

        return False

    def create_backup(self) -> bool:
        """Create a backup of the current state."""
        logger.info("Creating backup...")

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_branch = f"backup/before_cleanup_{timestamp}"

        # Create backup branch
        returncode, stdout, stderr = self.run_git_command(
            ["checkout", "-b", backup_branch]
        )

        if returncode != 0:
            logger.error(f"Failed to create backup branch: {stderr}")
            return False

        # Return to original branch
        returncode, stdout, stderr = self.run_git_command(["checkout", "-"])

        if returncode != 0:
            logger.error(f"Failed to return to original branch: {stderr}")
            return False

        logger.info(f"Backup created at branch: {backup_branch}")
        self.cleanup_operations.append(f"Created backup branch: {backup_branch}")

        return True

    def clean_file_contents(
        self, files_with_refs: dict[str, list[tuple[int, str]]]
    ) -> bool:
        """Clean Claude references from file contents."""
        logger.info("Cleaning Claude references from files...")

        if self.dry_run:
            logger.info("DRY RUN: Would clean the following files:")
            for file_path in files_with_refs:
                logger.info(f"  - {file_path}")
            return True

        cleaned_files = []

        for file_path, refs in files_with_refs.items():
            full_path = self.project_root / file_path

            try:
                # Read file content
                with open(full_path, encoding="utf-8") as f:
                    content = f.read()

                # Clean Claude references
                original_content = content

                # Remove obvious Claude comments and references
                patterns_to_remove = [
                    r"#.*[Cc]laude.*\n",
                    r"//.*[Cc]laude.*\n",
                    r"/\*.*[Cc]laude.*\*/\n?",
                    r'""".*[Cc]laude.*"""\n?',
                    r"'''.*[Cc]laude.*'''\n?",
                    r"<!--.*[Cc]laude.*-->\n?",
                ]

                for pattern in patterns_to_remove:
                    content = re.sub(
                        pattern, "", content, flags=re.IGNORECASE | re.DOTALL
                    )

                # Clean up any remaining obvious references
                for claude_pattern in self.claude_patterns:
                    # Only remove if it's in a comment-like context
                    comment_pattern = rf"(#|//|/\*|\*|<!--)\s*.*{claude_pattern}.*"
                    content = re.sub(comment_pattern, "", content, flags=re.IGNORECASE)

                # Write back if changed
                if content != original_content:
                    with open(full_path, "w", encoding="utf-8") as f:
                        f.write(content)

                    cleaned_files.append(file_path)
                    logger.info(f"Cleaned references from: {file_path}")

            except Exception as e:
                logger.error(f"Failed to clean {file_path}: {e}")
                return False

        if cleaned_files:
            self.cleanup_operations.append(f"Cleaned {len(cleaned_files)} files")

            # Stage the cleaned files
            returncode, stdout, stderr = self.run_git_command(["add"] + cleaned_files)

            if returncode != 0:
                logger.error(f"Failed to stage cleaned files: {stderr}")
                return False

        return True

    def generate_rebase_script(self, commits_to_clean: list[CommitInfo]) -> str:
        """Generate interactive rebase script."""
        logger.info("Generating interactive rebase script...")

        if not commits_to_clean:
            return ""

        # Create rebase script
        script_lines = []
        script_lines.append("#!/bin/bash")
        script_lines.append("# Interactive rebase script to clean commit messages")
        script_lines.append("# Generated by git_history_cleanup.py")
        script_lines.append("")

        # Get the parent of the oldest commit to clean
        oldest_commit = commits_to_clean[-1]
        returncode, stdout, stderr = self.run_git_command(
            ["rev-parse", f"{oldest_commit.hash}^"]
        )

        if returncode != 0:
            logger.error(f"Could not find parent commit: {stderr}")
            return ""

        parent_hash = stdout.strip()

        script_lines.append(f"# Rebase from parent of oldest commit: {parent_hash}")
        script_lines.append(f"git rebase -i {parent_hash}")
        script_lines.append("")
        script_lines.append("# Instructions:")
        script_lines.append(
            "# 1. Change 'pick' to 'reword' for commits you want to edit"
        )
        script_lines.append("# 2. Save and exit the editor")
        script_lines.append("# 3. For each commit, update the message when prompted")
        script_lines.append("")
        script_lines.append("# Suggested new messages:")

        for commit in commits_to_clean:
            script_lines.append(f"# {commit.short_hash}: {commit.suggested_message}")

        return "\n".join(script_lines)

    def interactive_cleanup(self) -> bool:
        """Run interactive cleanup process."""
        logger.info("Starting interactive cleanup process...")

        # Analyze history
        commits = self.analyze_commit_history()
        commits_with_claude = [c for c in commits if c.has_claude_refs]

        if not commits_with_claude:
            logger.info("No commits with Claude references found!")
            return True

        # Scan files
        files_with_refs = self.scan_files_for_claude_refs()

        # Show summary
        print(f"\n{Colors.BOLD}📊 Cleanup Summary{Colors.END}")
        print("=" * 50)
        print(f"Total commits analyzed: {len(commits)}")
        print(f"Commits with Claude references: {len(commits_with_claude)}")
        print(f"Files with Claude references: {len(files_with_refs)}")
        print()

        if commits_with_claude:
            print(f"{Colors.YELLOW}🔍 Commits needing cleanup:{Colors.END}")
            for commit in commits_with_claude[:10]:  # Show first 10
                print(f"  {commit.short_hash}: {commit.message[:60]}...")
                if commit.suggested_message:
                    print(f"    → {Colors.GREEN}{commit.suggested_message}{Colors.END}")

            if len(commits_with_claude) > 10:
                print(f"  ... and {len(commits_with_claude) - 10} more")
            print()

        if files_with_refs:
            print(f"{Colors.YELLOW}📁 Files needing cleanup:{Colors.END}")
            for file_path, refs in list(files_with_refs.items())[:5]:
                print(f"  {file_path} ({len(refs)} references)")

            if len(files_with_refs) > 5:
                print(f"  ... and {len(files_with_refs) - 5} more files")
            print()

        # Ask for confirmation
        if not self.dry_run:
            response = input(f"{Colors.CYAN}Continue with cleanup? (y/N): {Colors.END}")
            if response.lower() != "y":
                print("Cleanup cancelled.")
                return False

        # Create backup
        if not self.dry_run and not self.create_backup():
            return False

        # Clean file contents first
        if files_with_refs:
            success = self.clean_file_contents(files_with_refs)
            if not success:
                return False

        # Generate rebase script for commit messages
        if commits_with_claude:
            rebase_script = self.generate_rebase_script(commits_with_claude)

            script_file = self.project_root / "rebase_cleanup.sh"
            with open(script_file, "w") as f:
                f.write(rebase_script)

            script_file.chmod(0o755)

            print(
                f"\n{Colors.GREEN}📝 Rebase script generated: {script_file}{Colors.END}"
            )
            print(
                f"{Colors.YELLOW}To clean commit messages, run: ./rebase_cleanup.sh{Colors.END}"
            )

            self.cleanup_operations.append(
                f"Generated rebase script for {len(commits_with_claude)} commits"
            )

        return True

    def generate_cleanup_report(self) -> CleanupReport:
        """Generate cleanup report."""
        commits_with_claude = [c for c in self.commits if c.has_claude_refs]
        files_with_refs = self.scan_files_for_claude_refs()

        return CleanupReport(
            total_commits=len(self.commits),
            commits_with_claude_refs=len(commits_with_claude),
            files_with_claude_refs=len(files_with_refs),
            cleanup_operations=self.cleanup_operations.copy(),
            backup_created=any("backup" in op for op in self.cleanup_operations),
            success=True,
        )

    def save_report(self, report: CleanupReport, output_file: Path):
        """Save cleanup report to file."""
        with open(output_file, "w") as f:
            json.dump(asdict(report), f, indent=2)

        logger.info(f"Cleanup report saved to: {output_file}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Git history cleanup tool")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )
    parser.add_argument(
        "--analyze-only", action="store_true", help="Only analyze history, don't clean"
    )
    parser.add_argument(
        "--branch", default="HEAD", help="Branch to analyze (default: HEAD)"
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=100,
        help="Number of commits to analyze (default: 100)",
    )
    parser.add_argument(
        "--output", type=str, default="cleanup_report.json", help="Output report file"
    )

    args = parser.parse_args()

    # Find project root
    project_root = Path(__file__).parent.parent

    # Initialize cleanup tool
    cleanup = GitHistoryCleanup(project_root, dry_run=args.dry_run)

    try:
        if args.analyze_only:
            # Just analyze and report
            commits = cleanup.analyze_commit_history(args.branch, args.limit)
            files_with_refs = cleanup.scan_files_for_claude_refs()

            print(f"\n{Colors.BOLD}📊 Analysis Results{Colors.END}")
            print("=" * 50)
            print(f"Total commits: {len(commits)}")
            print(
                f"Commits with Claude refs: {len([c for c in commits if c.has_claude_refs])}"
            )
            print(f"Files with Claude refs: {len(files_with_refs)}")

        else:
            # Run interactive cleanup
            success = cleanup.interactive_cleanup()

            if success:
                print(f"\n{Colors.GREEN}✅ Cleanup completed successfully!{Colors.END}")
            else:
                print(f"\n{Colors.RED}❌ Cleanup failed or was cancelled{Colors.END}")
                sys.exit(1)

        # Generate and save report
        report = cleanup.generate_cleanup_report()
        cleanup.save_report(report, Path(args.output))

    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}⏸️  Cleanup interrupted by user{Colors.END}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Cleanup failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
